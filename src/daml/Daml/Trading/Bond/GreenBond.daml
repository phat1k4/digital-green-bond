module Daml.Trading.Bond.GreenBond where 

import DA.Optional (fromSome)
import DA.Set qualified as S 
import DA.Map (fromList)
import DA.Date (date, Month(..))
import DA.Time (time)
import DA.List (unique, sort)

import Daml.Finance.Interface.Types.Date.DayCount (DayCountConventionEnum)
-- import qualified Daml.Finance.Interface.Util.Disclosure as Disclosure
import Daml.Finance.Interface.Types.Date.Schedule (PeriodicSchedule)
import Daml.Finance.Interface.Account.Account qualified as Account (Credit(..), Debit(..),GetCid(..),I, exerciseInterfaceByKey)
import Daml.Finance.Interface.Holding.Base qualified as Holding (I, Base)
import Daml.Finance.Interface.Instrument.Base.Instrument qualified as Instrument (K, qty)
import Daml.Finance.Interface.Instrument.Bond.FixedRate.Factory qualified as FixedRate (Create(..))
import Daml.Finance.Interface.Instrument.Bond.FixedRate.Types qualified as FixedRate (FixedRate(..))
import Daml.Finance.Interface.Types.Date.Schedule qualified as Schedule (PeriodicSchedule(..), Frequency(..))
import Daml.Finance.Interface.Types.Date.Calendar qualified as Calendar
import Daml.Finance.Interface.Types.Date.RollConvention qualified as RollConvention
import Daml.Finance.Interface.Types.Date.DayCount qualified as DayCount 
import Daml.Finance.Interface.Types.Common.Types (AccountKey(..), Id(..), InstrumentKey(..))
import Daml.Trading.Account.Account (greenBondLabel, Account)
import Daml.Finance.Account.Account qualified as Account (T)
import Daml.Finance.Holding.NonFungible qualified as NonFungible
import Daml.Script (queryContractId)

data ImpactEnum
  = Social_Impact_1
  | Social_Impact_2
  | Environmental_Impact_1
  deriving (Eq, Show)

greenBondVersion = "0"

template GreenBondRequest
  with
    owner : Party
    arranger: Party
    legal_counsel: Party
    admin_account : Party
    depository : Party
    purpose : Text
    couponRate : Decimal
    periodicSchedule : PeriodicSchedule
    holidayCalendarIds : [Text]
    calendarDataProvider : Party
    dayCountConvention : DayCountConventionEnum
    cashInstrument : InstrumentKey
    notional : Decimal
    observers : S.Set Party 
    lastEventTimestamp : Time
    impact : ImpactEnum
    issue_amount : Int
  where
    signatory owner
    observer arranger, legal_counsel
    choice OwnerSign : ContractId RequestPending
      controller owner
        do
          let
            finalContract = GreenBondAgreement
              with
                signatories = [owner, legal_counsel, arranger]
                ..
          create RequestPending
            with
              alreadySigned = [owner]
              finalContract
              ..
    choice OwnerCancel : ()
      controller owner 
        do pure()

template RequestPending
  with
    alreadySigned: [Party]
    finalContract: GreenBondAgreement 
    purpose : Text
    couponRate : Decimal
    periodicSchedule : PeriodicSchedule
    holidayCalendarIds : [Text]
    calendarDataProvider : Party
    dayCountConvention : DayCountConventionEnum
    cashInstrument : InstrumentKey
    notional : Decimal
    observers : S.Set Party 
    lastEventTimestamp : Time
    impact : ImpactEnum
    issue_amount : Int
  where
    signatory alreadySigned
    observer finalContract.signatories
    ensure
      -- Can't have duplicate signatories
      unique alreadySigned

    -- The parties who need to sign is the finalContract.signatories with alreadySigned filtered out
    let toSign = filter (`notElem` alreadySigned) finalContract.signatories

    choice Approve : ContractId RequestPending 
      with
        signer : Party
      controller signer
        do
          -- Check the controller is in the toSign list, and if they are, sign the Pending contract
          assert (signer `elem` toSign)
          create this with alreadySigned = signer :: alreadySigned
    
    choice Finalize : ContractId GreenBondAgreement with
        signer : Party
      controller signer
        do
          -- Check that all the required signatories have signed Pending
          assert (sort alreadySigned == sort finalContract.signatories)
          create finalContract
    choice Reject : ()
      with
        signer : Party
      controller signer
        do pure ()

template GreenBondAgreement
  with
    signatories: [Party]
    admin_account : Party
    depository : Party
    owner : Party
    arranger : Party
    legal_counsel : Party
    purpose : Text
    couponRate : Decimal
    periodicSchedule : PeriodicSchedule
    holidayCalendarIds : [Text]
    calendarDataProvider : Party
    dayCountConvention : DayCountConventionEnum
    cashInstrument : InstrumentKey
    notional : Decimal
    observers : S.Set Party 
    lastEventTimestamp : Time
    impact : ImpactEnum
    issue_amount : Int
  where
    signatory signatories
    observer owner, admin_account, depository
    choice Accept : Instrument.K
      controller admin_account 
      do
        let 
          accountKey = AccountKey with custodian = admin_account, owner, id = Id greenBondLabel
          amount = intToNumeric (issue_amount)
          instrumentKey = InstrumentKey with depository=admin_account, issuer = owner, id = Id purpose, version = greenBondVersion
        (accountCid, account) <- fetchByKey @Account (admin_account, owner) 

        let 
          (_, _, instrumentFactoryCid, _) = fromSome account.optGreenBondAccount 
          fixedRate = FixedRate.FixedRate with 
            instrument = instrumentKey 
            description = purpose 
            couponRate
            periodicSchedule
            holidayCalendarIds
            calendarDataProvider
            dayCountConvention 
            currency = cashInstrument 
            lastEventTimestamp

        now <- getTime 

        exercise instrumentFactoryCid FixedRate.Create with 
          fixedRate
          observers = fromList [("InstrumentObserver", observers)]
        
        greenbondHoldingCid <- Account.exerciseInterfaceByKey @Account.I accountKey admin_account Account.Credit
          with
            quantity = Instrument.qty amount instrumentKey

        create GreenBond with ..
        pure (instrumentKey)

    choice Decline : ()
      controller admin_account
      do pure ()


template GreenBond
  with
    -- depository : Party
      -- ^ The depository of the green bond.
    -- issuer : Party
      -- ^ The issuer of the green bond.
    -- id : Id
    --   -- ^ The identifier of the green bond.
    -- version : Text
      -- ^ The green bond's version.
    instrumentKey: Instrument.K 
    accountKey: AccountKey
    purpose : Text
      -- ^ A description of the green bond.
    couponRate : Decimal
      -- ^ The fixed coupon rate, per annum. For example, in case of a "3.5% p.a coupon" this should
      --   be 0.035. This can also used as a floating coupon spread. For example, in case of
      --   "3M Libor + 0.5%" this should be 0.005.
    periodicSchedule : PeriodicSchedule
      -- ^ The schedule for the periodic coupon payments. The coupon is paid on the last date of
      --   each schedule period.
    holidayCalendarIds : [Text]
      -- ^ The identifiers of the holiday calendars to be used for the coupon schedule.
    calendarDataProvider : Party
      -- ^ The reference data provider to use for the holiday calendar.
    dayCountConvention : DayCountConventionEnum
      -- ^ The day count convention used to calculate day count fractions. For example: Act360.
    cashInstrument : InstrumentKey
      -- ^ The currency of the bond. For example, if the bond pays in USD this should be a USD cash
      --   instrument.
    notional : Decimal
      -- ^ The notional of the bond. This is the face value corresponding to one unit of the bond
      --   instrument. For example, if one bond unit corresponds to 1000 USD, this should be 1000.0.
    observers : S.Set Party 
      -- ^ The observers of the instrument.
    lastEventTimestamp : Time
      -- ^ (Market) time of the last recorded lifecycle event. If no event has occurred yet, the
      --   time of creation should be used.
    impact : ImpactEnum
    issue_amount : Int
      -- ^ Defines whether the bond has a social or environmental impact.
  -- CALLABLE_BOND_TEMPLATE_END
  where
    signatory accountKey.custodian, accountKey.owner
    observer observers
    key instrumentKey: Instrument.K 
    maintainer key.issuer


template GreenbondTransferRequest
  with
    depository: Party
    owner: Party 
    custodian: Party 
    instrument : Instrument.K
    amount : Decimal
  where
    signatory depository
    observer custodian, owner

    ensure amount > 0.0

    nonconsuming choice AdminAccept : ContractId Holding.I
      controller custodian
      do
        let
          accountKey = AccountKey with custodian, owner=depository, id = Id greenBondLabel
        accountholdingCid <- Account.exerciseInterfaceByKey @Account.I accountKey custodian Account.Credit
          with
            quantity = Instrument.qty amount instrument
        pure(accountholdingCid)

    choice OwnerDebit : ()
      controller owner
      do
        --TODO: archive old NonFungible of owner
        (accountCid, account) <- fetchByKey @Account (custodian, owner)
        let
          accountKey = AccountKey with custodian, owner, id = Id greenBondLabel
          newaccountCid : ContractId Holding.Base = coerceContractId accountCid
        accountholdingCid <- Account.exerciseInterfaceByKey @Account.I accountKey custodian Account.Debit
          with
            holdingCid = newaccountCid
        pure(accountholdingCid)
    
    choice OwnerDecline : ()
      controller owner
      do pure ()